
==============================
Modern React and Redux Notes
==============================

Javascript modules
-> all the code that we write in other files is separated.
-> code has 0 contact from one another unless you explicitly demand access (export and import) to the files.

#React-DOM is a separate library that is in charge of rendering components into the DOM, not the main React library
#React library -> create and manage components

JSX tag, with no content, you can do self-closing tags like <App />

We need to instantiate our components before passing them over to the DOM.
-> App is a component class, and we're passing a class over to the DOM
-> Instead, we need an instance of an component
-> <App /> is an instance of the App component class.

`ReactDOM.render(<App />, document.querySelector('.container'));`

The second argument is a HTML node element that tells ReactDOM which node element to render our component into.
It'll find the .container HTML node, and whatever we have in <App/> will exist inside .container

Using React, you need to know how to break-down our app into different components.
E.g. Search-bar should be its own component.

index.js should be the main component
The rest of the components will be in different files (modularity), no matter how small the component is.
Modular js files need to import React, as the transpiled code for defining a component needs to reference React.
Importing files require a proper file reference.

#Functional component & Class-based component
-> Class based component are used when we need to manipulate State.
-> Functional Components are used when we need to take in info, and produce JSX. 
-> Functional component can contain class-based component
-> 

# STATE
is a plain JS object to record & react to events
-> Each instance of a class-based Component we define has it's own state object. (functional no state)
-> Whenever a component is changed, it re-renders, also forcing all its children to re-render too.
-> Before using state, need to Init state.
-> You can add additional fields to the class to store something for visual output. Thus, if something is not used in `render()`, it shouldn't be in the state.

`this.state = { term: '' };`

-> Updating state is different from creating our state. Only state constructor will look like the above code.

`this.setState({ term: e.target.value})`

-> We use setState to update the fields in state, and then use

`{this.state.term}` which gets the `term` field from state.

-> When we do `value = {this.state.term}`, this becomes a controlled Component. A controlled Component only can change its value when the state changes. (user can't edit anything)
