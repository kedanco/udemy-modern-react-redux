
==============================
Modern React and Redux Notes
==============================
# REACT


Javascript modules
-> all the code that we write in other files is separated.
-> code has 0 contact from one another unless you explicitly demand access (export and import) to the files.

#React-DOM is a separate library that is in charge of rendering components into the DOM, not the main React library
#React library -> create and manage components

JSX tag, with no content, you can do self-closing tags like <App />

We need to instantiate our components before passing them over to the DOM.
-> App is a component class, and we're passing a class over to the DOM
-> Instead, we need an instance of an component
-> <App /> is an instance of the App component class.

`ReactDOM.render(<App />, document.querySelector('.container'));`

The second argument is a HTML node element that tells ReactDOM which node element to render our component into.
It'll find the .container HTML node, and whatever we have in <App/> will exist inside .container

Using React, you need to know how to break-down our app into different components.
E.g. Search-bar should be its own component.

index.js should be the main component
The rest of the components will be in different files (modularity), no matter how small the component is.
Modular js files need to import React, as the transpiled code for defining a component needs to reference React.
Importing files require a proper file reference.

#Functional component & Class-based component
-> Class based component are used when we need to manipulate State.
-> Functional Components are used when we need to take in info, and produce JSX. 
-> Functional component can contain class-based component
-> 

# STATE
is a plain JS object to record & react to events
-> Each instance of a class-based Component we define has it's own state object. (functional no state)
-> Whenever a component is changed, it re-renders, also forcing all its children to re-render too.
-> Before using state, need to Init state.
-> You can add additional fields to the class to store something for visual output. Thus, if something is not used in `render()`, it shouldn't be in the state.

`this.state = { term: '' };`

-> Updating state is different from creating our state. Only state constructor will look like the above code.

`this.setState({ term: e.target.value})`

-> We use setState to update the fields in state, and then use

`{this.state.term}` which gets the `term` field from state.

-> When we do `value = {this.state.term}`, this becomes a controlled Component. A controlled Component only can change its value when the state changes. (user can't edit anything)

-> `this.setState({videos: videos});` can be condensed in ES6 as `this.setState({ videos })`;

#Downwards Data Flow
Only the most parent component to be the one fetching data from external sources (index)

Fetching data may require some time, and thus any data required during document load may not be instant.
Some parent objects can't fetch the data fast enough before the child objects load
-> Face errors where var is undefined, but var has a value when you test it.
-> Can consider adding an AJAX spinner 'loading', but not for every component in the page.

#Props
-> In functional component, `props` exist as an argument
-> In class-based component, `props` exist in this.props
-> when we refactor our components from functional to class-based, we need to change our props to this.props

#Listkeys
-> A unique tracker/ID for a list item
-> Even if re-render component, the key will be the same (able to perform edits)

#Selecting and rendering different list items
index.js -> onVideoSelect fn only updates app state. It is passed as a property into VideoList, which gets passed into VideoList Item, and into Video. (Passing callbacks)

#Searchterm
1. Refactor YTsearch term into a videoSearch fn
2. pass videoSearch method into SearchBar, under onSearchTermChange, with new `term`
3. Inside SearchBar, refactor onchange event, to call onInputChange with new event Value
4. onInputChange setstate of component, and fires off the callback of onSearchTermChange.

#Throttling search
`const videoSearch = _.debounce((term) => { this.videoSearch(term) }, 300);` 

this.state -> component level state

=====================
# REDUX
=====================

#Split the app into Data, and Views
Redux -> A collection of all the data used in the App, an application-level state. keeping track of the data
      -> We centralize all of the data into one object, the state.
React -> In-charge of the views, rendering the data on the webpage

# Reducer
A function that returns a piece of the App State
-> Our app can have many different pieces of state.
-> Only return non-undefined value
-> Never mutate the current state for a new version, return a fresh object
  ```
    state.title = book.title
    return state
  ```
---------------------------------------------------------

  E.g. Booklist application can have diff reducers
  
  ```
  Books reducer and activeBooks reducer
    {
      books: [ {title: 'Harry Potter'}, {title: 'Javascript'} ],
      activeBook: { title: 'Javascript: The Good Parts'}
    }
  ```

All Reducers get 2 arguments
1) Current State - not application state, but a lower-level state that the reducer is responsible for.
2) Action - since reducers only called when theres an action

To make use of Reducer in other parts of our project, we need to export our Reducer function, and import into index.js

#Promote Component into a Container
-> Container also called 'smart components' compared to 'dumb components' (no connection to redux)
-> Through a 3rd library, ReactRedux
-> We want the most parent component that cares about a particular piece of state to be a container 
-> App doesn't care about state change, only rendering of components

#Simple said - if only care about display, no need to bother about data.
#If parent component needs to do state change with data - then convert it to container

Whenever application state changes
-> the mapStateToProps will immediately re-render with a new list of books
-> The object in the state function will end up as 'props' inside of BookList

# Containers and Reducers review
1) Redux -> construct application state
   React -> Construct views to display that state.
   connected by react-redux library
2) Application state is generated by Reducer functions -> reducer_books
    reducer_books.js always returns an array of books.
3) We added this books reducer to our combineReducers call inside index.js. This reducer adds a key to our global application state.
  `books: BooksReducer` Key & value
4) Component BookList -> BookList has to be aware of app state, so it got promoted to a Container.
    a) import connect from react-redux
    b) define mapStateToProps function
    c) connect mapStateToProps BookList
5) We chose BookList because it is the parent component that needs to care about app state
6) Redux generated a state object containing books, and mapped that state as `props` to our component.
7) Component re-rendered with list of books whenever there's an update.


# Actions and Action Creators
1) user clicks on a button - calls Action Creator
2) Action Creator creates an action (returns an object - an action)
3) Action object is sent to all reducers inside our application
4) Reducer will have a switch w/ different cases (different actions).
    > If reducer doesn't care about action, reducer just returns current state
    > If it cares, it will return a new application state.
    > because the reducer <-- linked --> key in state, return value of reducer becomes new value of state
5) Once all reducers have processed the actions, the `New State` goes into different containers, and containers will re-render will the updated data.


#Conditional Rendering
-> Reducers may pass in null value as state, and view would not have a value to render.
-> Do a check (if !value to display!) then return a filler value 

# Intermediate Redux -> Middleware
